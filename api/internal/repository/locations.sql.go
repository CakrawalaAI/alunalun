// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: locations.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPinsInArea = `-- name: CountPinsInArea :one
SELECT COUNT(*) 
FROM posts p
JOIN posts_location pl ON p.id = pl.post_id
WHERE p.type = 'pin'
    AND p.created_at > NOW() - INTERVAL '24 hours'
    AND ST_Within(
        pl.coordinates,
        ST_MakeEnvelope($1, $2, $3, $4, 4326)
    )
`

type CountPinsInAreaParams struct {
	StMakeenvelope   interface{} `json:"st_makeenvelope"`
	StMakeenvelope_2 interface{} `json:"st_makeenvelope_2"`
	StMakeenvelope_3 interface{} `json:"st_makeenvelope_3"`
	StMakeenvelope_4 interface{} `json:"st_makeenvelope_4"`
}

func (q *Queries) CountPinsInArea(ctx context.Context, arg *CountPinsInAreaParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPinsInArea,
		arg.StMakeenvelope,
		arg.StMakeenvelope_2,
		arg.StMakeenvelope_3,
		arg.StMakeenvelope_4,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPostLocation = `-- name: CreatePostLocation :one
INSERT INTO posts_location (post_id, coordinates, geohash, created_at)
VALUES ($1, ST_SetSRID(ST_MakePoint($2, $3), 4326), $4, $5)
RETURNING 
    post_id,
    ST_X(coordinates) as longitude,
    ST_Y(coordinates) as latitude,
    geohash,
    created_at
`

type CreatePostLocationParams struct {
	PostID        pgtype.UUID        `json:"post_id"`
	StMakepoint   interface{}        `json:"st_makepoint"`
	StMakepoint_2 interface{}        `json:"st_makepoint_2"`
	Geohash       string             `json:"geohash"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

type CreatePostLocationRow struct {
	PostID    pgtype.UUID        `json:"post_id"`
	Longitude interface{}        `json:"longitude"`
	Latitude  interface{}        `json:"latitude"`
	Geohash   string             `json:"geohash"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreatePostLocation(ctx context.Context, arg *CreatePostLocationParams) (*CreatePostLocationRow, error) {
	row := q.db.QueryRow(ctx, createPostLocation,
		arg.PostID,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.Geohash,
		arg.CreatedAt,
	)
	var i CreatePostLocationRow
	err := row.Scan(
		&i.PostID,
		&i.Longitude,
		&i.Latitude,
		&i.Geohash,
		&i.CreatedAt,
	)
	return &i, err
}

const deletePostLocation = `-- name: DeletePostLocation :exec
DELETE FROM posts_location WHERE post_id = $1
`

func (q *Queries) DeletePostLocation(ctx context.Context, postID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePostLocation, postID)
	return err
}

const getPinWithLocation = `-- name: GetPinWithLocation :one
SELECT 
    p.id, p.user_id, p.type, p.parent_id, p.content, p.visibility, p.metadata, p.created_at,
    u.username as author_username,
    u.display_name as author_display_name,
    u.avatar_url as author_avatar_url,
    ST_X(pl.coordinates) as longitude,
    ST_Y(pl.coordinates) as latitude,
    pl.geohash,
    pl.created_at as location_created_at
FROM posts p
LEFT JOIN users u ON p.user_id = u.id
JOIN posts_location pl ON p.id = pl.post_id
WHERE p.id = $1 AND p.type = 'pin'
`

type GetPinWithLocationRow struct {
	ID                pgtype.UUID        `json:"id"`
	UserID            pgtype.UUID        `json:"user_id"`
	Type              string             `json:"type"`
	ParentID          pgtype.UUID        `json:"parent_id"`
	Content           string             `json:"content"`
	Visibility        *string            `json:"visibility"`
	Metadata          []byte             `json:"metadata"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	AuthorUsername    *string            `json:"author_username"`
	AuthorDisplayName *string            `json:"author_display_name"`
	AuthorAvatarUrl   *string            `json:"author_avatar_url"`
	Longitude         interface{}        `json:"longitude"`
	Latitude          interface{}        `json:"latitude"`
	Geohash           string             `json:"geohash"`
	LocationCreatedAt pgtype.Timestamptz `json:"location_created_at"`
}

func (q *Queries) GetPinWithLocation(ctx context.Context, id pgtype.UUID) (*GetPinWithLocationRow, error) {
	row := q.db.QueryRow(ctx, getPinWithLocation, id)
	var i GetPinWithLocationRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.ParentID,
		&i.Content,
		&i.Visibility,
		&i.Metadata,
		&i.CreatedAt,
		&i.AuthorUsername,
		&i.AuthorDisplayName,
		&i.AuthorAvatarUrl,
		&i.Longitude,
		&i.Latitude,
		&i.Geohash,
		&i.LocationCreatedAt,
	)
	return &i, err
}

const getPostLocation = `-- name: GetPostLocation :one
SELECT 
    post_id,
    ST_X(coordinates) as longitude,
    ST_Y(coordinates) as latitude,
    geohash,
    created_at
FROM posts_location
WHERE post_id = $1
`

type GetPostLocationRow struct {
	PostID    pgtype.UUID        `json:"post_id"`
	Longitude interface{}        `json:"longitude"`
	Latitude  interface{}        `json:"latitude"`
	Geohash   string             `json:"geohash"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetPostLocation(ctx context.Context, postID pgtype.UUID) (*GetPostLocationRow, error) {
	row := q.db.QueryRow(ctx, getPostLocation, postID)
	var i GetPostLocationRow
	err := row.Scan(
		&i.PostID,
		&i.Longitude,
		&i.Latitude,
		&i.Geohash,
		&i.CreatedAt,
	)
	return &i, err
}

const listNearbyPins = `-- name: ListNearbyPins :many
SELECT 
    p.id, p.user_id, p.type, p.parent_id, p.content, p.visibility, p.metadata, p.created_at,
    u.username as author_username,
    u.display_name as author_display_name,
    u.avatar_url as author_avatar_url,
    ST_X(pl.coordinates) as longitude,
    ST_Y(pl.coordinates) as latitude,
    pl.geohash,
    ST_Distance(
        pl.coordinates::geography,
        ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography
    ) as distance_meters
FROM posts p
LEFT JOIN users u ON p.user_id = u.id
JOIN posts_location pl ON p.id = pl.post_id
WHERE p.type = 'pin' 
    AND p.created_at > NOW() - INTERVAL '24 hours'
    AND ST_DWithin(
        pl.coordinates::geography,
        ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography,
        $3  -- radius in meters
    )
ORDER BY distance_meters ASC
LIMIT $4
`

type ListNearbyPinsParams struct {
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
	StDwithin     interface{} `json:"st_dwithin"`
	Limit         int32       `json:"limit"`
}

type ListNearbyPinsRow struct {
	ID                pgtype.UUID        `json:"id"`
	UserID            pgtype.UUID        `json:"user_id"`
	Type              string             `json:"type"`
	ParentID          pgtype.UUID        `json:"parent_id"`
	Content           string             `json:"content"`
	Visibility        *string            `json:"visibility"`
	Metadata          []byte             `json:"metadata"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	AuthorUsername    *string            `json:"author_username"`
	AuthorDisplayName *string            `json:"author_display_name"`
	AuthorAvatarUrl   *string            `json:"author_avatar_url"`
	Longitude         interface{}        `json:"longitude"`
	Latitude          interface{}        `json:"latitude"`
	Geohash           string             `json:"geohash"`
	DistanceMeters    interface{}        `json:"distance_meters"`
}

func (q *Queries) ListNearbyPins(ctx context.Context, arg *ListNearbyPinsParams) ([]*ListNearbyPinsRow, error) {
	rows, err := q.db.Query(ctx, listNearbyPins,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.StDwithin,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListNearbyPinsRow{}
	for rows.Next() {
		var i ListNearbyPinsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.ParentID,
			&i.Content,
			&i.Visibility,
			&i.Metadata,
			&i.CreatedAt,
			&i.AuthorUsername,
			&i.AuthorDisplayName,
			&i.AuthorAvatarUrl,
			&i.Longitude,
			&i.Latitude,
			&i.Geohash,
			&i.DistanceMeters,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPinsByGeohash = `-- name: ListPinsByGeohash :many
SELECT 
    p.id, p.user_id, p.type, p.parent_id, p.content, p.visibility, p.metadata, p.created_at,
    u.username as author_username,
    u.display_name as author_display_name,
    u.avatar_url as author_avatar_url,
    ST_X(pl.coordinates) as longitude,
    ST_Y(pl.coordinates) as latitude,
    pl.geohash
FROM posts p
LEFT JOIN users u ON p.user_id = u.id
JOIN posts_location pl ON p.id = pl.post_id
WHERE p.type = 'pin' 
    AND p.created_at > NOW() - INTERVAL '24 hours'
    AND pl.geohash LIKE $1 || '%'
ORDER BY p.created_at DESC
LIMIT $2
`

type ListPinsByGeohashParams struct {
	Column1 *string `json:"column_1"`
	Limit   int32   `json:"limit"`
}

type ListPinsByGeohashRow struct {
	ID                pgtype.UUID        `json:"id"`
	UserID            pgtype.UUID        `json:"user_id"`
	Type              string             `json:"type"`
	ParentID          pgtype.UUID        `json:"parent_id"`
	Content           string             `json:"content"`
	Visibility        *string            `json:"visibility"`
	Metadata          []byte             `json:"metadata"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	AuthorUsername    *string            `json:"author_username"`
	AuthorDisplayName *string            `json:"author_display_name"`
	AuthorAvatarUrl   *string            `json:"author_avatar_url"`
	Longitude         interface{}        `json:"longitude"`
	Latitude          interface{}        `json:"latitude"`
	Geohash           string             `json:"geohash"`
}

func (q *Queries) ListPinsByGeohash(ctx context.Context, arg *ListPinsByGeohashParams) ([]*ListPinsByGeohashRow, error) {
	rows, err := q.db.Query(ctx, listPinsByGeohash, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListPinsByGeohashRow{}
	for rows.Next() {
		var i ListPinsByGeohashRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.ParentID,
			&i.Content,
			&i.Visibility,
			&i.Metadata,
			&i.CreatedAt,
			&i.AuthorUsername,
			&i.AuthorDisplayName,
			&i.AuthorAvatarUrl,
			&i.Longitude,
			&i.Latitude,
			&i.Geohash,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPinsInBoundingBox = `-- name: ListPinsInBoundingBox :many
SELECT 
    p.id, p.user_id, p.type, p.parent_id, p.content, p.visibility, p.metadata, p.created_at,
    u.username as author_username,
    u.display_name as author_display_name,
    u.avatar_url as author_avatar_url,
    ST_X(pl.coordinates) as longitude,
    ST_Y(pl.coordinates) as latitude,
    pl.geohash
FROM posts p
LEFT JOIN users u ON p.user_id = u.id
JOIN posts_location pl ON p.id = pl.post_id
WHERE p.type = 'pin' 
    AND p.created_at > NOW() - INTERVAL '24 hours'
    AND ST_Within(
        pl.coordinates,
        ST_MakeEnvelope($1, $2, $3, $4, 4326)
    )
ORDER BY p.created_at DESC
LIMIT $5 OFFSET $6
`

type ListPinsInBoundingBoxParams struct {
	StMakeenvelope   interface{} `json:"st_makeenvelope"`
	StMakeenvelope_2 interface{} `json:"st_makeenvelope_2"`
	StMakeenvelope_3 interface{} `json:"st_makeenvelope_3"`
	StMakeenvelope_4 interface{} `json:"st_makeenvelope_4"`
	Limit            int32       `json:"limit"`
	Offset           int32       `json:"offset"`
}

type ListPinsInBoundingBoxRow struct {
	ID                pgtype.UUID        `json:"id"`
	UserID            pgtype.UUID        `json:"user_id"`
	Type              string             `json:"type"`
	ParentID          pgtype.UUID        `json:"parent_id"`
	Content           string             `json:"content"`
	Visibility        *string            `json:"visibility"`
	Metadata          []byte             `json:"metadata"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	AuthorUsername    *string            `json:"author_username"`
	AuthorDisplayName *string            `json:"author_display_name"`
	AuthorAvatarUrl   *string            `json:"author_avatar_url"`
	Longitude         interface{}        `json:"longitude"`
	Latitude          interface{}        `json:"latitude"`
	Geohash           string             `json:"geohash"`
}

func (q *Queries) ListPinsInBoundingBox(ctx context.Context, arg *ListPinsInBoundingBoxParams) ([]*ListPinsInBoundingBoxRow, error) {
	rows, err := q.db.Query(ctx, listPinsInBoundingBox,
		arg.StMakeenvelope,
		arg.StMakeenvelope_2,
		arg.StMakeenvelope_3,
		arg.StMakeenvelope_4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListPinsInBoundingBoxRow{}
	for rows.Next() {
		var i ListPinsInBoundingBoxRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.ParentID,
			&i.Content,
			&i.Visibility,
			&i.Metadata,
			&i.CreatedAt,
			&i.AuthorUsername,
			&i.AuthorDisplayName,
			&i.AuthorAvatarUrl,
			&i.Longitude,
			&i.Latitude,
			&i.Geohash,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
