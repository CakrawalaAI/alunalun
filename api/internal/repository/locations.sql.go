// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: locations.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPostLocation = `-- name: CreatePostLocation :one
INSERT INTO posts_location (post_id, location, geohash, created_at)
VALUES ($1, ST_SetSRID(ST_MakePoint($2, $3), 4326), $4, $5)
RETURNING 
    post_id,
    ST_X(location) as longitude,
    ST_Y(location) as latitude,
    geohash,
    created_at
`

type CreatePostLocationParams struct {
	PostID        string             `json:"post_id"`
	StMakepoint   interface{}        `json:"st_makepoint"`
	StMakepoint_2 interface{}        `json:"st_makepoint_2"`
	Geohash       *string            `json:"geohash"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

type CreatePostLocationRow struct {
	PostID    string             `json:"post_id"`
	Longitude interface{}        `json:"longitude"`
	Latitude  interface{}        `json:"latitude"`
	Geohash   *string            `json:"geohash"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreatePostLocation(ctx context.Context, arg *CreatePostLocationParams) (*CreatePostLocationRow, error) {
	row := q.db.QueryRow(ctx, createPostLocation,
		arg.PostID,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.Geohash,
		arg.CreatedAt,
	)
	var i CreatePostLocationRow
	err := row.Scan(
		&i.PostID,
		&i.Longitude,
		&i.Latitude,
		&i.Geohash,
		&i.CreatedAt,
	)
	return &i, err
}

const deletePostLocation = `-- name: DeletePostLocation :exec
DELETE FROM posts_location WHERE post_id = $1
`

func (q *Queries) DeletePostLocation(ctx context.Context, postID string) error {
	_, err := q.db.Exec(ctx, deletePostLocation, postID)
	return err
}

const getPinWithLocation = `-- name: GetPinWithLocation :one
SELECT 
    p.id, p.user_id, p.type, p.content, p.parent_id, p.metadata, p.created_at, p.updated_at,
    pl.post_id, pl.location, pl.geohash, pl.created_at
FROM posts p
JOIN posts_location pl ON p.id = pl.post_id
WHERE p.id = $1
    AND p.type = 'pin'
`

type GetPinWithLocationRow struct {
	ID          string             `json:"id"`
	UserID      string             `json:"user_id"`
	Type        string             `json:"type"`
	Content     *string            `json:"content"`
	ParentID    *string            `json:"parent_id"`
	Metadata    []byte             `json:"metadata"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	PostID      string             `json:"post_id"`
	Location    interface{}        `json:"location"`
	Geohash     *string            `json:"geohash"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

func (q *Queries) GetPinWithLocation(ctx context.Context, id string) (*GetPinWithLocationRow, error) {
	row := q.db.QueryRow(ctx, getPinWithLocation, id)
	var i GetPinWithLocationRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.Content,
		&i.ParentID,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PostID,
		&i.Location,
		&i.Geohash,
		&i.CreatedAt_2,
	)
	return &i, err
}

const getPostLocation = `-- name: GetPostLocation :one
SELECT 
    post_id,
    ST_X(location) as longitude,
    ST_Y(location) as latitude,
    geohash,
    created_at
FROM posts_location
WHERE post_id = $1
`

type GetPostLocationRow struct {
	PostID    string             `json:"post_id"`
	Longitude interface{}        `json:"longitude"`
	Latitude  interface{}        `json:"latitude"`
	Geohash   *string            `json:"geohash"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) GetPostLocation(ctx context.Context, postID string) (*GetPostLocationRow, error) {
	row := q.db.QueryRow(ctx, getPostLocation, postID)
	var i GetPostLocationRow
	err := row.Scan(
		&i.PostID,
		&i.Longitude,
		&i.Latitude,
		&i.Geohash,
		&i.CreatedAt,
	)
	return &i, err
}

const listNearbyPins = `-- name: ListNearbyPins :many
SELECT 
    p.id, p.user_id, p.type, p.content, p.parent_id, p.metadata, p.created_at, p.updated_at,
    u.username as author_username,
    ST_X(pl.location) as longitude,
    ST_Y(pl.location) as latitude,
    pl.geohash,
    ST_Distance(
        pl.location::geography,
        ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography
    ) as distance_meters,
    COALESCE(comment_counts.count, 0) as comment_count
FROM posts p
JOIN users u ON p.user_id = u.id
JOIN posts_location pl ON p.id = pl.post_id
LEFT JOIN (
    SELECT parent_id, COUNT(*) as count
    FROM posts
    WHERE parent_id IS NOT NULL
    GROUP BY parent_id
) comment_counts ON p.id = comment_counts.parent_id
WHERE p.type = 'pin'
    AND ST_DWithin(
        pl.location::geography,
        ST_SetSRID(ST_MakePoint($1, $2), 4326)::geography,
        $3  -- radius in meters
    )
ORDER BY distance_meters ASC
LIMIT $4
`

type ListNearbyPinsParams struct {
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
	StDwithin     interface{} `json:"st_dwithin"`
	Limit         int32       `json:"limit"`
}

type ListNearbyPinsRow struct {
	ID             string             `json:"id"`
	UserID         string             `json:"user_id"`
	Type           string             `json:"type"`
	Content        *string            `json:"content"`
	ParentID       *string            `json:"parent_id"`
	Metadata       []byte             `json:"metadata"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	AuthorUsername string             `json:"author_username"`
	Longitude      interface{}        `json:"longitude"`
	Latitude       interface{}        `json:"latitude"`
	Geohash        *string            `json:"geohash"`
	DistanceMeters interface{}        `json:"distance_meters"`
	CommentCount   int64              `json:"comment_count"`
}

func (q *Queries) ListNearbyPins(ctx context.Context, arg *ListNearbyPinsParams) ([]*ListNearbyPinsRow, error) {
	rows, err := q.db.Query(ctx, listNearbyPins,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.StDwithin,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListNearbyPinsRow{}
	for rows.Next() {
		var i ListNearbyPinsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Content,
			&i.ParentID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorUsername,
			&i.Longitude,
			&i.Latitude,
			&i.Geohash,
			&i.DistanceMeters,
			&i.CommentCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPinsByGeohash = `-- name: ListPinsByGeohash :many
SELECT 
    p.id, p.user_id, p.type, p.content, p.parent_id, p.metadata, p.created_at, p.updated_at,
    pl.post_id, pl.location, pl.geohash, pl.created_at
FROM posts p
JOIN posts_location pl ON p.id = pl.post_id
WHERE p.type = 'pin'
    AND pl.geohash LIKE $1 || '%'
ORDER BY p.created_at DESC
LIMIT $2
`

type ListPinsByGeohashParams struct {
	Column1 *string `json:"column_1"`
	Limit   int32   `json:"limit"`
}

type ListPinsByGeohashRow struct {
	ID          string             `json:"id"`
	UserID      string             `json:"user_id"`
	Type        string             `json:"type"`
	Content     *string            `json:"content"`
	ParentID    *string            `json:"parent_id"`
	Metadata    []byte             `json:"metadata"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	PostID      string             `json:"post_id"`
	Location    interface{}        `json:"location"`
	Geohash     *string            `json:"geohash"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

func (q *Queries) ListPinsByGeohash(ctx context.Context, arg *ListPinsByGeohashParams) ([]*ListPinsByGeohashRow, error) {
	rows, err := q.db.Query(ctx, listPinsByGeohash, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListPinsByGeohashRow{}
	for rows.Next() {
		var i ListPinsByGeohashRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Content,
			&i.ParentID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PostID,
			&i.Location,
			&i.Geohash,
			&i.CreatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPinsInBoundingBox = `-- name: ListPinsInBoundingBox :many
SELECT 
    p.id, p.user_id, p.type, p.content, p.parent_id, p.metadata, p.created_at, p.updated_at,
    u.username as author_username,
    ST_X(pl.location) as longitude,
    ST_Y(pl.location) as latitude,
    pl.geohash,
    COALESCE(comment_counts.count, 0) as comment_count
FROM posts p
JOIN users u ON p.user_id = u.id
JOIN posts_location pl ON p.id = pl.post_id
LEFT JOIN (
    SELECT parent_id, COUNT(*) as count
    FROM posts
    WHERE parent_id IS NOT NULL
    GROUP BY parent_id
) comment_counts ON p.id = comment_counts.parent_id
WHERE p.type = 'pin'
    AND ST_Within(
        pl.location,
        ST_MakeEnvelope($1, $2, $3, $4, 4326)
    )
ORDER BY p.created_at DESC
LIMIT $5 OFFSET $6
`

type ListPinsInBoundingBoxParams struct {
	StMakeenvelope   interface{} `json:"st_makeenvelope"`
	StMakeenvelope_2 interface{} `json:"st_makeenvelope_2"`
	StMakeenvelope_3 interface{} `json:"st_makeenvelope_3"`
	StMakeenvelope_4 interface{} `json:"st_makeenvelope_4"`
	Limit            int32       `json:"limit"`
	Offset           int32       `json:"offset"`
}

type ListPinsInBoundingBoxRow struct {
	ID             string             `json:"id"`
	UserID         string             `json:"user_id"`
	Type           string             `json:"type"`
	Content        *string            `json:"content"`
	ParentID       *string            `json:"parent_id"`
	Metadata       []byte             `json:"metadata"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	AuthorUsername string             `json:"author_username"`
	Longitude      interface{}        `json:"longitude"`
	Latitude       interface{}        `json:"latitude"`
	Geohash        *string            `json:"geohash"`
	CommentCount   int64              `json:"comment_count"`
}

func (q *Queries) ListPinsInBoundingBox(ctx context.Context, arg *ListPinsInBoundingBoxParams) ([]*ListPinsInBoundingBoxRow, error) {
	rows, err := q.db.Query(ctx, listPinsInBoundingBox,
		arg.StMakeenvelope,
		arg.StMakeenvelope_2,
		arg.StMakeenvelope_3,
		arg.StMakeenvelope_4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListPinsInBoundingBoxRow{}
	for rows.Next() {
		var i ListPinsInBoundingBoxRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.Content,
			&i.ParentID,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AuthorUsername,
			&i.Longitude,
			&i.Latitude,
			&i.Geohash,
			&i.CommentCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
