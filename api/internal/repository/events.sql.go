// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: events.sql

package repository

import (
	"context"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

const countEventsByType = `-- name: CountEventsByType :one
SELECT COUNT(*) as count
FROM user_events
WHERE (user_id = $1 OR session_id = $2)
AND event_type = $3
AND created_at > $4
`

type CountEventsByTypeParams struct {
	UserID    pgtype.UUID
	SessionID pgtype.UUID
	EventType string
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) CountEventsByType(ctx context.Context, arg CountEventsByTypeParams) (int64, error) {
	row := q.db.QueryRow(ctx, countEventsByType,
		arg.UserID,
		arg.SessionID,
		arg.EventType,
		arg.CreatedAt,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRecentEvents = `-- name: CountRecentEvents :one
SELECT COUNT(*) as count
FROM user_events
WHERE (user_id = $1 OR session_id = $2)
AND created_at > $3
`

type CountRecentEventsParams struct {
	UserID    pgtype.UUID
	SessionID pgtype.UUID
	CreatedAt pgtype.Timestamptz
}

func (q *Queries) CountRecentEvents(ctx context.Context, arg CountRecentEventsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRecentEvents, arg.UserID, arg.SessionID, arg.CreatedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUserEvent = `-- name: CreateUserEvent :one
INSERT INTO user_events (
    user_id, session_id, event_type, ip_address, 
    x_forwarded_for, x_real_ip, user_agent, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, user_id, session_id, event_type, ip_address, x_forwarded_for, x_real_ip, user_agent, created_at, metadata
`

type CreateUserEventParams struct {
	UserID        pgtype.UUID
	SessionID     pgtype.UUID
	EventType     string
	IpAddress     *netip.Addr
	XForwardedFor *string
	XRealIp       *netip.Addr
	UserAgent     *string
	Metadata      []byte
}

func (q *Queries) CreateUserEvent(ctx context.Context, arg CreateUserEventParams) (UserEvent, error) {
	row := q.db.QueryRow(ctx, createUserEvent,
		arg.UserID,
		arg.SessionID,
		arg.EventType,
		arg.IpAddress,
		arg.XForwardedFor,
		arg.XRealIp,
		arg.UserAgent,
		arg.Metadata,
	)
	var i UserEvent
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.EventType,
		&i.IpAddress,
		&i.XForwardedFor,
		&i.XRealIp,
		&i.UserAgent,
		&i.CreatedAt,
		&i.Metadata,
	)
	return i, err
}

const getRecentSessionEvents = `-- name: GetRecentSessionEvents :many
SELECT id, user_id, session_id, event_type, ip_address, x_forwarded_for, x_real_ip, user_agent, created_at, metadata FROM user_events 
WHERE session_id = $1 
AND created_at > $2 
ORDER BY created_at DESC 
LIMIT $3
`

type GetRecentSessionEventsParams struct {
	SessionID pgtype.UUID
	CreatedAt pgtype.Timestamptz
	Limit     int32
}

func (q *Queries) GetRecentSessionEvents(ctx context.Context, arg GetRecentSessionEventsParams) ([]UserEvent, error) {
	rows, err := q.db.Query(ctx, getRecentSessionEvents, arg.SessionID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserEvent{}
	for rows.Next() {
		var i UserEvent
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.EventType,
			&i.IpAddress,
			&i.XForwardedFor,
			&i.XRealIp,
			&i.UserAgent,
			&i.CreatedAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentUserEvents = `-- name: GetRecentUserEvents :many
SELECT id, user_id, session_id, event_type, ip_address, x_forwarded_for, x_real_ip, user_agent, created_at, metadata FROM user_events 
WHERE user_id = $1 
AND created_at > $2 
ORDER BY created_at DESC 
LIMIT $3
`

type GetRecentUserEventsParams struct {
	UserID    pgtype.UUID
	CreatedAt pgtype.Timestamptz
	Limit     int32
}

func (q *Queries) GetRecentUserEvents(ctx context.Context, arg GetRecentUserEventsParams) ([]UserEvent, error) {
	rows, err := q.db.Query(ctx, getRecentUserEvents, arg.UserID, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserEvent{}
	for rows.Next() {
		var i UserEvent
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.EventType,
			&i.IpAddress,
			&i.XForwardedFor,
			&i.XRealIp,
			&i.UserAgent,
			&i.CreatedAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
